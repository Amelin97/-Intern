// Example 1
let a1 = 'Text';
let b1 = a1;
a1 = 'another text'; //тут мы работаем с простыми объектами поэтому он копируються целиком
console.log('a1 = ', a1);
console.log('b1 = ', b1);

// Example 2
let a2 = 28;
let b2 = a2; 
a2 = 41; 		//так же как ^ любые простые элементы(строки , числа , булевы знчения , null , undefined) копируються целиком
console.log('a2 = ', a2); 
console.log('b2 = ', b2);

// Example 3
let a3 = {
	name: 'Ivan Ivanov',
	age: 41,
};		// тут мы работем собъктами поэтому строка let b3 = a3; просто копирует ссылку объекта  a3 в b3 , т.е они остаються связанными
let b3 = a3;
a3.name = 'Igor Petrov';
console.log('a3 = ', a3);
console.log('b3 = ', b3);

// Example 4
let a4 = [1,3,5,7,9];
let b4 = a4;  
a4 = [2,4,6,8,10]; // тут по новой инициализируеться массив а4 , а б4 ссылаеться на на предыдущую инициализацию
console.log('a4 = ', a4);// если перед второй инициализацией изменить элемент по индексу то будет работать 
console.log('b4 = ', b4);//как копирование по ссылке

// Example 5
let a5 = [1,2,3,4,5];
let b5 = a5;
a5[0] = 0;			// тут как раз мы работаем с объектом поэтому копируеться ссылка на объект 
console.log('a5 = ', a5);//и изменения а5 видны в б5 и наоборот 
console.log('b5 = ', b5);

// Example 6
let a6 = [1,2,3,4,5];
let b6 = a6;
a6.push(6); //  все так же как и выше
console.log('a6 = ', a6);
console.log('b6 = ', b6);

// Example 7
let a7 = [{
	name: 'Vasya',
  age: 12
}, {
	name: 'Misha',
  age: 14
}, {
	name: 'Pavel',
  age: 13
}];
let b7 = a7;  //это озачает что б7 содержит в себе ссылку а7 поэтому они связаны

a7.map((obj)=> {
		obj.name = obj.name + ' Pupkin';
		obj.age = obj.age;
});
console.log('a7 = ', a7);
console.log('b7 = ', b7);

/*
Копирование от клонирования отличаеться тем что ,
при копировании в объекте в который мы копируем 
храниться не сам объект , а ссылка на него .
Т.е. если мы меняем значение в одном из объектов 
то изменения применяються ко обоим т.к. объект 
из которого мы копируем остаеться
 в единственном экземпляре.
 При клонировании создаеться просто такой же объект
 который хранит все те же знечения что и 1
 и если мы изменяем клон объекта то изменения не будут
 применяться к оригиналу и наоборот


Глубокая копия означает, 
что все значения новой переменной копируются и отключаются от исходной переменной.
Мелкая копия означает, что определенные (под) значения все еще связаны с исходной переменной.


*/ 